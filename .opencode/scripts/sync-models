#!/usr/bin/env bun

/**
 * sync-models
 * 
 * Syncs Ollama models to .opencode/opencode.json provider configuration.
 * Models are added to provider.ollama.models following OpenCode's config schema.
 * 
 * Usage: ./.opencode/scripts/sync-models
 */

import { exec } from "child_process";
import { promisify } from "util";
import { readFileSync, writeFileSync, existsSync } from "fs";
import { join } from "path";

const execAsync = promisify(exec);

const REPO_ROOT = process.cwd();
const OPENCODE_CONFIG = join(REPO_ROOT, ".opencode/opencode.json");
const MODELS_DIR = join(REPO_ROOT, "models");

interface OllamaModel {
  name: string;
  tag: string;
  size: string;
  id: string;
  modified: string;
}

async function getInstalledModels(): Promise<OllamaModel[]> {
  try {
    const { stdout } = await execAsync("ollama list");
    const lines = stdout.trim().split("\n").slice(1); // Skip header
    
    return lines.map((line) => {
      const parts = line.trim().split(/\s+/);
      const [nameTag, id, ...sizeParts] = parts;
      const [name, tag = "latest"] = nameTag.split(":");
      
      // Size is everything after ID until the last 2-3 parts (which are the date)
      const modified = parts.slice(-3).join(" ");
      const size = parts.slice(2, -3).join(" ");
      
      return { name, tag, size, id, modified };
    });
  } catch (error) {
    console.error("Error getting installed models:", error);
    return [];
  }
}

function updateOpenCodeConfig(models: OllamaModel[]) {
  let config: any = {};
  
  if (existsSync(OPENCODE_CONFIG)) {
    config = JSON.parse(readFileSync(OPENCODE_CONFIG, "utf-8"));
  }
  
  // Initialize provider.ollama if it doesn't exist
  if (!config.provider) {
    config.provider = {};
  }
  
  if (!config.provider.ollama) {
    config.provider.ollama = {
      npm: "@ai-sdk/openai-compatible",
      name: "Ollama (local)",
      options: {
        baseURL: "http://localhost:11434/v1"
      },
      models: {}
    };
  }
  
  if (!config.provider.ollama.models) {
    config.provider.ollama.models = {};
  }
  
  // Add/update all installed models to the provider.ollama.models object
   for (const model of models) {
     const modelKey = `${model.name}:${model.tag}`;
     config.provider.ollama.models[modelKey] = {
       name: formatModelName(model.name, model.tag),
       description: `${model.size} ‚Ä¢ ${model.modified}`
     };
   }
  
  writeFileSync(OPENCODE_CONFIG, JSON.stringify(config, null, 2));
  console.log(`‚úÖ Updated ${OPENCODE_CONFIG}`);
}

function formatModelName(name: string, tag: string): string {
   // Convert model:tag to human-readable format
   // e.g., "qwen2.5-coder:32b" -> "Qwen 2.5 Coder 32B"
   const words = name.split(/[-_]/).map(word => 
     word.charAt(0).toUpperCase() + word.slice(1)
   );
   const formattedTag = tag.toUpperCase();
   return `${words.join(" ")} ${formattedTag}`;
}

function normalizeModelName(name: string, tag: string): string {
  // Convert model:tag to filename-friendly format
  return `${name}-${tag}`.replace(/[^a-z0-9-]/gi, "-").replace(/-+/g, "-");
}

async function main() {
  console.log("üîç Scanning installed Ollama models...");
  const models = await getInstalledModels();
  
  if (models.length === 0) {
    console.log("‚ùå No models found. Install models with: ollama pull <model>");
    process.exit(1);
  }
  
  console.log(`üì¶ Found ${models.length} installed models`);
  models.forEach(m => console.log(`   - ${m.name}:${m.tag} (${m.size})`));
  
  console.log("\nüîß Updating OpenCode configuration...");
  updateOpenCodeConfig(models);
  
  console.log("\n‚úÖ Sync complete!");
  console.log("\nOllama models configured:");
  const config = JSON.parse(readFileSync(OPENCODE_CONFIG, "utf-8"));
  const ollamaModels = config.provider?.ollama?.models || {};
  for (const [modelKey, modelConfig] of Object.entries(ollamaModels)) {
    console.log(`   ${modelKey}: ${(modelConfig as any).name}`);
  }
}

main().catch(console.error);
